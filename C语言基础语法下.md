C语言基础语法下

# 一、数组

## 1.随机访问

数组实现随机访问的关键在于其**数据结构的连续内存分配**以及**固定的元素大小**。

上述两点意味着数组中元素的地址，均匀可以连续计算，是实现随机访问必不可少的前提。

了解上述前提后，我们还需要知道两个概念：**基地址与偏移量**，我们要想随机访问数组的某个元素，就需要知道目标元素的地址。

[目标元素的地址] = 数组基地址 + 偏移量，其中：

1. 数组的基地址，即首元素的地址，也是数组变量的地址。**实际上，数组名在内存中就代表该数组的基地址。**
2. 偏移量指的是目标元素地址和首元素地址的字节差值。**恰好这个字节差值就等于：[目标元素的下标i] \* [sizeof_element]** 

**寻址公式**：

```c
address(arr[i]) = base_address(arr) + i * sizeof_element
```

假如我们有一个长度为5的int数组，其基地址是0x0053fbd4，要访问第五个元素，即arr[4]，那么根据寻址公式就可以计算出地址：

address_arr[4] =  0x0053fbd4 + (4 * 4) = 0x0053fbe4

所以，每次你用**"arr[4]"**这样的语法访问数组时，程序会直接访问**0x0053fbe4**这个地址来获取或设置元素值，不再需要查找或遍历，效率非常高，这就是随机访问的魅力。

**数组下标为什么从0开始?**

> 尽管C语言并非首个采用从0开始的数组下标设计的语言，但由于其广泛的影响，许多后续的编程语言基本沿用了这一设计。
>
> 采取这样的设计，主要原因是为了**简化偏移量的计算，从而提高数组的效率**，具体来说是：
>
> 如果从0开始作为数组的下标，那么下标值可以直接用于计算偏移量。反之，如果从1开始，那么每次寻址都需要额外执行一个减法操作（即数组下标减1）。
>
> 简而言之，以0为数组下标的起始值，可以避免额外的减法运算，从而提高数组访问的效率。
>
> 如果你还不太明白，可以用一个简单的楼层比喻来理解：
>
> 假设数组下标从1开始。这就好比你从1楼开始上楼，当你走到3楼时，你实际上经过了2层，怎么算的呢？相当于做了一个(3-1)的减法计算，所以你的“偏移量”是2。
>
> 而当数组下标从0开始。就像你从0楼（假设某栋大楼第一层是0楼）开始上楼。
>
> 这次当你走到3楼时，你实际上经过了3层，怎么算的呢？0到1，1到2，3到3，所以就经过了3层。
>
> 这说明从0楼开始，到几楼，就经过了几楼，偏移量就是几，无需额外的计算。和补码统一加减法类似，这里将下标设置为从0开始，就减少了一次减法操作，大大提升了效率。

**二维数组元素的随机访问机制**

例如一个二维数组的声明如下：

```c
int arr[3][4];
```

这意味着arr是一个有3个元素的数组，每个元素又是一个有4个整数的数组。在内存中，这个数组是这样存储的(**"行主序"**)：

当你尝试访问 arr\[i][j]元素时，依然是随机访问的。对于二维数组，C 语言使用以下寻址公式计算其内存位置地址：

```c
address(arr[i][j]) = base_address + (i * cols_num) * sizeof_element + j * sizeof_element
```

其中：

1. base_address是数组的基地址，实际上就是二维数组中第一个一维数组的第一个元素的地址。同样的，二维数组名在内存中就代表这个地址。
2. cols_num是每行的元素数量，也就是列长（也就是一维数组的长度，这里是4）
3. sizeof_element是数组元素的大小（在这里是int的大小，一般是4）。

为了保证上述计算的准确性，每个子数组（或说每一行）的长度必须保持一致。如果每行的元素数量变得不一致，该公式就无法准确地计算内存地址，从而导致错误的数组元素访问。

这就是为什么在 C 语言的标准二维数组中，每个一维数组的长度必须相同的原因。

![image-20241016190538399](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016190538399.png)

![image-20241016191527430](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016191527430.png)

# 二、函数

## 1.exit和return

`EXIT_SUCCESS` 和 `EXIT_FAILURE` 都是定义在 <stdlib.h> 中的宏常量，它们的值是由实现决定的，通常分别为 0 和 1。

`return`语句和`exit`函数之间的差异是：

不管哪个函数调用`exit`函数都会导致程序终止，`return`语句仅当在`main`函数中执行时才会导致程序的终止。

![image-20241016193850304](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016193850304.png)

![image-20241016193908274](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016193908274.png)

## 2.常见变量分类

根据变量的定义位置、存储位置、存储期限（生命周期）、作用域等的不同，C语言中的变量主要有以下几种类型：

1. **局部变量 (Local Variable)**
2. **全局变量 (Global Variable)**
3. **静态局部变量 (Static Local Variable)**

### 2.1 局部变量

在C语言中，**局部变量就是在函数当中定义的变量**，它最主要的特点就是只在声明它的"{}"内部有效。

操作系统为每个执行的C程序（进程）分配虚拟内存空间，局部变量存储在一片被称之为"栈（stack）"的内存区域。

栈的工作原理是**后进先出**，这意味着最后放入栈的项是第一个被移除的。

在C程序的运行过程中，每当一个函数被调用，系统会为其创建一个**“栈帧”**来存储该函数的执行上下文，并将这个栈帧压入栈顶，这个过程称为**函数进栈（push）**。一个函数被调用，就是函数栈帧进栈的的过程。

栈帧中会存储此函数的局部变量（包括形式参数）。

当函数开始执行，对应的栈帧被压入栈顶时，局部变量得以初始化并生效。随着函数执行完毕，栈帧从栈顶中弹出，此时，函数内的局部变量也随之被销毁，这个过程称为**函数出栈（pop）**。

所以局部变量的生命周期与包含它们的函数的生命周期是一致的：

1. 当函数被调用时，其局部变量被创建；
2. 当函数返回时，这些变量被销毁。

在C语言当中，这种**"依托于变量存储空间单元存在而存在"**的变量生命周期形式被称为**"自动存储期限"**。局部变量的自动存储期限，依赖于函数调用栈。

C语言的局部变量没有自动的初始化机制，如果一个局部变量仅有声明没有手动初始化（赋值），那么此局部变量的初始值是未定义的，它的值可以是任意的、随机的"垃圾值"。

使用未初始化的局部变量可能导致程序行为的不确定性和不可预测性。因此，为了保证程序的稳定性和预测性，最佳实践是始终在使用变量之前对其进行初始化。

### 2.2 全局变量

在C语言中，全局变量也是一种特别常见的变量类型，有时它也被称为外部变量。

这是因为它们**在函数之外被定义**，并且**可以在整个文件内，甚至其他文件中（通过外部链接）被访问和使用。**

局变量被存储在虚拟内存空间当中，一片被称之为**"数据段"**的内存区域当中。

不同于局部变量随着函数的调用和返回被创建和销毁，**全局变量的生命周期从程序开始执行时开始，持续到程序完全结束。**

**简而言之，全局变量与程序的生命周期同步：它们在程序开始时被创建并初始化，并在程序结束时被销毁。**

在C语言中，这种持续存在于程序整个执行周期的生命周期特性被称为**“静态存储期限”**。

**全局变量的作用域从"声明位置"开始，并延申至整个程序。**具体来说：

1. 在定义全局变量的文件内，全局变量可以在其声明之后的任何位置被访问和修改。
2. 要想在其他源文件中使用该全局变量，可以通过**extern关键字**来引用它。

关于跨文件调用函数，一般步骤如下：

1. 在一个头文件中**声明**你想跨文件调用的函数。
2. 在一个源文件中包含头文件，然后**定义**这个函数。（包含自定义头文件，使用**#include "xx.h"**）
3. 在另一个源文件中，包含头文件并**直接调用**该函数。

static修饰的全局变量的主要效果是将其**作用域限制在声明它的文件中**，这意味着该变量只能在它所在的源文件中被访问和修改。其它的特性，如生命周期、初始化方式和存储位置，与普通的全局变量是相同的。

比如上面的global_num全局变量，一旦使用static关键字修饰，再次运行程序，就会产生链接错误。因为此时的全局变量已经不能被链接到外部使用了。

### 2.3 静态局部变量

静态局部变量的存储位置和生命周期和全局变量是一致的：

1. 都是存储在数据段区域当中。
2. 生命周期都是从程序启动到程序结束，都是"静态存储期限"。

这就意味着，静态局部变量与一般的局部变量不同：

**静态局部变量不会随着函数的返回而销毁，它会始终保留到程序执行完毕。**

不要将静态局部变量理解成"活得更长"的局部变量，局部变量和静态局部变量在初始化方面有非常大的区别。

**静态局部变量的初始化特性**：

1. **默认初始化**：如果不显式地为静态局部变量提供一个初始值，系统会默认将其初始化为0值。
2. **初始化只有一次**：静态局部变量只会在其所在函数，第一次被调用时初始化一次。此后，不论调用几次该函数，都不会再次初始化了。

静态局部变量的作用域仅限于其所在的函数。这意味着：

**尽管静态局部变量的生命周期与程序的整个执行期间一致，但它只能在定义它的函数内部被访问。**

## 3.递归

**一个函数直接或间接地调用自己，我们称这种现象为“递归”。简而言之，递归是一种函数自调用的行为。**

除此之外，我们还可"抠字眼"来理解递归，将递归分为"递"和"归"两部分：

递：“递”意味着“递推”，即将一个较大规模的问题逐步分解成较小的、更容易处理的子问题。

归："归"意味着"返回"或"回归"，当我们解决了这些子问题后，会从最底层开始，逐步合并或组合这些子问题的答案，直至得出最初问题的解答。

这种“递推-回归”的思维模式是递归的核心，也是其强大之处。

**递归三要素：**

1. **递归体（体现“递”过程）：**
   1. 函数内部递归调用自身的部分。
   2. 递归体是递归思维的核心：它表示如何将一个大规模问题“递推”为较小、相似的子问题。这一分解过程持续地缩小问题规模，以便更容易处理。
2. **递归的出口（体现“归”过程）：**
   1. 当子问题已经足够小或满足某种条件时，我们不再继续分解，而是开始返回答案。这些条件或情况就是递归的出口。
   2. 明确的递归出口是至关重要的。没有明确的出口，递归可能无限进行，直到耗尽资源并导致栈溢出。通过递归的出口，我们实现了从“递”到“归”的转换，开始逐步合并或组合子问题的答案。
3. **递归的深度：**
   1. 每次递归调用都会加深调用的层次，这可以被看作是递归“递”的深度。
   2. 控制递归深度是至关重要的，因为一个过深的递归不仅会增加计算复杂性，还可能导致栈溢出。合理的深度能确保我们在“递”的过程中不会过分深入，同时在“归”的过程中能够有效地返回和组合答案。

例子：递归求解前n个自然数的累加。

![image-20241017173039027](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017173039027.png)

1. **递归体**："return n + sum(n-1); "

   这里的递归体体现了将大问题（如求1到n的和）分解为小问题（求1到n-1的和）的思想。对小问题的求解建立在更小问题的基础上，形成一个递归链条。

2. **递归出口**："if (n == 1) { return 1; } "

   当n值为1时，函数返回1而不再递归调用自身。这是递归的终止条件，确保了递归有一个明确的结束点。

3. **递归深度**： 对于这个函数，递归深度与输入的num值有关。

   例如，当我们调用sum(5)，递归深度为5，因为从sum(5)开始，会连续调用sum(4), sum(3), sum(2), 和sum(1)。每一次调用都会在栈上增加一个新的函数调用帧。

   如果不断增大n的值，递归深度也会增加，这可能导致效率下降，甚至在极端情况下出现栈溢出。

### 3.1 汉诺塔问题

首先看一下汉诺塔问题的描述：

相传在古印度的圣庙中，有一种被称之为汉诺塔（也叫河内塔）的游戏。

简单来说：有三个塔1，2，3，塔1上有 N 个（N>=1）穿孔圆盘，大盘在下，小盘在上。

要求按下列规则将所有圆盘移至塔3：

1. 每次只能移动一个圆盘。
2. 任何时候，大圆盘都不能放在小圆盘的上面。

提示：可将圆盘临时置于塔2，也可以将塔1的圆盘重新移回塔1，但都必须遵循上述两条规则。

问：当塔1上有N（N>=1）个圆盘时，最少要移动多少次？（注意是最少）



**如果选择递归解法，那就思考分解问题，大规模问题化成小规模，分析如下：**：

先来玩三把（N<=3）的汉诺塔游戏：

1. 当N = 1时，直接把盘子从塔1到塔3，仅需1步。**（这就可以作为递归出口）**
2. 当N=2时，先把小盘子移到塔2，再把大盘子移到塔3，最后把小盘子放入塔3，共3步。
3. 当N=3时，先把最小的盘子移到塔3，再把中间的盘子移到塔2。
   1. 然后把最小的盘子移到塔2，最大的盘子移到塔3
   2. 随后最小的盘子移到塔1，中间的盘子移到塔3，最小的盘子移到塔3，共7步

对于N个盘子的汉诺塔问题，我们假设至少需要f(N)步来完成，这f(N)步可以做以下分解：

1. 将前n-1个圆盘从**塔1**移动到**塔2**，此过程需要塔3作为辅助。 **这一步就是把N-1个盘子从一个塔移到另一个塔，共需要f(N-1)步。**
2. 将最大的1个盘子，从**塔1**移动到**塔3**。 **共需要1步完成。**
3. 再将将前n-1个圆盘从**塔2**移动到**塔3**。**这一步就是把N-1个盘子从一个塔移到另一个塔，共需要f(N-1)步。**

于是我们就分解了N个盘子的汉诺塔问题：

**f(N) = f(N-1) + 1 + f(N-1) = 2 \* f(N-1) + 1，这就是递归体。**

找到递归出口和递归体，递归就可以写出来了。

![image-20241017191920199](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017191920199.png)

![image-20241017191929205](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017191929205.png)

![image-20241017191942390](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017191942390.png)

# 三、指针

![指针变量-示意图](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20240516090057610.png)

## 1.数组名和指针

**数组名是一个代表数组在内存中起始地址的标识符，在大多数上下文中，数组名可以被视为指向首元素的指针。**

进一步解释：

1. **从功能上看，数组名的行为类似于一个固定指向首元素地址的，不可改变指向的指针。**
2. 从语义上讲，数组名代表的是整个数组，而不仅仅是地址。

例如，声明了一个数组**"int arr[5]"**时，数组名arr就代表了这个数组在内存中的起始地址（也就是首元素地址），而且不可被修改。

以下是一些常见的场景，其中数组名会被当作指向首元素的指针使用：

1. 数组名可以直接用于初始化一个指针变量，此时的数组名就当成首元素的指针使用。

   ```c
   arr = NULL;     // 报错
   arr = { 2 };    // 报错
   ```

2. 当一个数组作为参数传给一个函数时，数组名**隐式转换（也称退化）**为指向其首元素的指针。

3. 数组名可以直接进行指针算术运算，此时的数组名就当成首元素的指针使用。

**作为参数传递时，数组名会退化为首元素的指针，为什么叫退化呢？**

之所叫退化，而不是进化，主要原因是：

1. **信息丢失**：**数组在传递时失去了其数组长度的信息。**例如，如果你有一个大小为10的数组，当它被传递到函数时，函数不再知道它的长度。
2. **语义变化**：在数组没有传入函数时，它代表整个数组。但在函数内部，该名称只是一个指针，只代表数组的第一个元素。这是一个从"更丰富"到"更简单"的转变，所以用“退化”这个词来描述是恰当的。

**总之，我们讲数组“退化”为指针，主要是指在传递数组时丢失了其原有属性，而只保留了最基本的，即首元素的地址。**



虽然在许多场合，数组名表现得像指向其首元素的指针，但在某些场景中，将数组名当作指针是不恰当的。

以下是这些特定场景的说明：

**&取地址运算。**

在做取地址运算时，数组名代表整个数组，而不是首元素的指针。也就是说对数组名取地址，就是对数组变量取地址，得到的是代表整个数组的地址。

当然，变量的地址是变量内存空间的第一个字节的内存地址，对于数组而言就是首元素的地址。

也就是说：

数组名在视为指针时，和对数组名取地址得到的结果值是一样的，都是存储数组首元素地址的指针。但很明显，这两个指针的类型以及含义是截然不同的！！

以一个类型为`int[5]`，即长度为5的int数组为例：

1. 数组名视为指针时，存储的是首元素的地址，指向数组首元素。数组名作为指针时的类型是`int *`类型。
2. 对数组名取地址时，得到的是整个数组变量的地址，虽然从地址值上它还是指向数组首元素，但类型变成了`int[5] *`。这个指针指向的是整个数组变量，而不是数组首元素。

![image-20241022180746979](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241022180746979.png)

## 2.数组指针和指针数组

数组指针" 和 "指针数组" 是两种完全不同的概念：

1. 数组指针是一个实际开发中比较罕见的语法，了解即可。
2. **指针数组则比较重要，也比较常用。**

**数组指针（Pointer to an Array）**

**定义：数组指针是一个指针，它是一个指向整个数组的指针。**

**声明：**例如，要声明一个指向包含5个整数元素的数组的指针，你可以这样做：

```c
int arr[5];
int (*ptr_to_arr)[5] = &arr;  // ptr_to_arr 是一个指向包含5个整数的数组的指针
```

数组指针声明的语法中，非常关键的就是"**(\*指针名)**"，一定要加上小括号，你知道为什么吗？

实际上是因取下标运算符(`[]`)的优先级高于解引用运算符(`*`)，不加小括号整体就是一个数组即指针数组，而不是数组指针。

**用途：**

数组指针通常在函数参数中用来指向和传递二维数组。但一来二维数组比较少用，二来就算要用二维数组传参，直接按下面的写法就可以了：

```c
// 二维数组作为形参时，必须指定列数，行数则不需要指定
void process_matrix(int (*matrix)[5], int rows) {
}
// 等价于
void process_matrix(int matrix[][5], int rows) {
}
```

**指针数组（Array of Pointers）**

**定义：**指针数组是一个数组，它是一个元素都是指针变量的数组。**

**声明：**

例如，要声明一个包含5个整数指针元素的数组，你可以这样做：

```c
// ptr_arr和ptr_arr2是可以装5个int*类型指针元素的数组
int *ptr_arr[5] = { 0 };  //全部初始化为空指针

int a = 1, b = 2, c = 3, d = 4, e = 5;
int *ptr_arr2[5] = {&a, &b, &c, &d, &e};  // 用指针变量进行初始化
```

**用途：**

指针数组最常见的用途就是存储字符串数组。除此之外，它们还在多种数据结构中发挥重要作用，例如函数指针数组、动态数据结构等。

3.常量指针和指针常量

**常量指针 (Constant Pointer)**

**含义：指针本身是一个常量，指针无法指向一个新的对象。但可以利用该指针修改指向的对象！**

定义形式：

```c
int a = 10;
int b = 20;
// p指针是一个常量,它无法指向新的对象,但利用该指针可以修改指向的对象
int* const p = &a;  // const修饰的是指针p，所以指针p本身是一个常量
*p = 30;
// p = &b; error
```

建议：

我不建议在任何场景下，直接提"常量指针"四个字，因为这四个字实在无法描述语法本来的含义。当你看到**"类型\* const 指针名"**这样的语法时：

1. 你可以直白的用中文讲"const修饰指针，指针本身是一个常量，无法修改指针的指向"。
2. 你也可以直接提它的英语单词"Constant Pointer"（不可变的指针）。

**指针常量 (Pointer to Constant)**

**含义：无法利用指针修改指向的内容，但指针本身可以指向不同的对象。**

定义形式：

```c
int a = 10;
int b = 20;

// 无法使用指针p修改变量a的取值,但该指针可以指向新的对象
const int* p = &a;  // 也可以用"int const *p"; 此时const修饰的*p，也就是指针指向的对象是一个常量
//*p = 30; error
p = &b;
```

**不要将"指针常量"语法理解成指向一个常量的指针，实际上该语法只意味着"无法利用该指针修改指向的内容"，指针指向的实际是一个变量也完全可以。**

建议：

我不建议在任何场景下，直接提"指针常量"四个字，因为这四个字实在无法描述语法本来的含义。当你看到**"const 类型\* 指针名"**这样的语法时：

1. 你可以直接用中文讲"这是一个无法修改指向内容的指针"
2. 也可以记住它的英文单词"Pointer to Constant"

