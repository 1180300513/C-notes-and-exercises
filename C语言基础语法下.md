C语言基础语法下

# 一、数组

## 1.随机访问

数组实现随机访问的关键在于其**数据结构的连续内存分配**以及**固定的元素大小**。

上述两点意味着数组中元素的地址，均匀可以连续计算，是实现随机访问必不可少的前提。

了解上述前提后，我们还需要知道两个概念：**基地址与偏移量**，我们要想随机访问数组的某个元素，就需要知道目标元素的地址。

[目标元素的地址] = 数组基地址 + 偏移量，其中：

1. 数组的基地址，即首元素的地址，也是数组变量的地址。**实际上，数组名在内存中就代表该数组的基地址。**
2. 偏移量指的是目标元素地址和首元素地址的字节差值。**恰好这个字节差值就等于：[目标元素的下标i] \* [sizeof_element]** 

**寻址公式**：

```c
address(arr[i]) = base_address(arr) + i * sizeof_element
```

假如我们有一个长度为5的int数组，其基地址是0x0053fbd4，要访问第五个元素，即arr[4]，那么根据寻址公式就可以计算出地址：

address_arr[4] =  0x0053fbd4 + (4 * 4) = 0x0053fbe4

所以，每次你用**"arr[4]"**这样的语法访问数组时，程序会直接访问**0x0053fbe4**这个地址来获取或设置元素值，不再需要查找或遍历，效率非常高，这就是随机访问的魅力。

**数组下标为什么从0开始?**

> 尽管C语言并非首个采用从0开始的数组下标设计的语言，但由于其广泛的影响，许多后续的编程语言基本沿用了这一设计。
>
> 采取这样的设计，主要原因是为了**简化偏移量的计算，从而提高数组的效率**，具体来说是：
>
> 如果从0开始作为数组的下标，那么下标值可以直接用于计算偏移量。反之，如果从1开始，那么每次寻址都需要额外执行一个减法操作（即数组下标减1）。
>
> 简而言之，以0为数组下标的起始值，可以避免额外的减法运算，从而提高数组访问的效率。
>
> 如果你还不太明白，可以用一个简单的楼层比喻来理解：
>
> 假设数组下标从1开始。这就好比你从1楼开始上楼，当你走到3楼时，你实际上经过了2层，怎么算的呢？相当于做了一个(3-1)的减法计算，所以你的“偏移量”是2。
>
> 而当数组下标从0开始。就像你从0楼（假设某栋大楼第一层是0楼）开始上楼。
>
> 这次当你走到3楼时，你实际上经过了3层，怎么算的呢？0到1，1到2，3到3，所以就经过了3层。
>
> 这说明从0楼开始，到几楼，就经过了几楼，偏移量就是几，无需额外的计算。和补码统一加减法类似，这里将下标设置为从0开始，就减少了一次减法操作，大大提升了效率。

**二维数组元素的随机访问机制**

例如一个二维数组的声明如下：

```c
int arr[3][4];
```

这意味着arr是一个有3个元素的数组，每个元素又是一个有4个整数的数组。在内存中，这个数组是这样存储的(**"行主序"**)：

当你尝试访问 arr\[i][j]元素时，依然是随机访问的。对于二维数组，C 语言使用以下寻址公式计算其内存位置地址：

```c
address(arr[i][j]) = base_address + (i * cols_num) * sizeof_element + j * sizeof_element
```

其中：

1. base_address是数组的基地址，实际上就是二维数组中第一个一维数组的第一个元素的地址。同样的，二维数组名在内存中就代表这个地址。
2. cols_num是每行的元素数量，也就是列长（也就是一维数组的长度，这里是4）
3. sizeof_element是数组元素的大小（在这里是int的大小，一般是4）。

为了保证上述计算的准确性，每个子数组（或说每一行）的长度必须保持一致。如果每行的元素数量变得不一致，该公式就无法准确地计算内存地址，从而导致错误的数组元素访问。

这就是为什么在 C 语言的标准二维数组中，每个一维数组的长度必须相同的原因。

![image-20241016190538399](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016190538399.png)

![image-20241016191527430](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016191527430.png)

# 二、函数

## 1.exit和return

`EXIT_SUCCESS` 和 `EXIT_FAILURE` 都是定义在 <stdlib.h> 中的宏常量，它们的值是由实现决定的，通常分别为 0 和 1。

`return`语句和`exit`函数之间的差异是：

不管哪个函数调用`exit`函数都会导致程序终止，`return`语句仅当在`main`函数中执行时才会导致程序的终止。

![image-20241016193850304](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016193850304.png)

![image-20241016193908274](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241016193908274.png)

## 2.常见变量分类

根据变量的定义位置、存储位置、存储期限（生命周期）、作用域等的不同，C语言中的变量主要有以下几种类型：

1. **局部变量 (Local Variable)**
2. **全局变量 (Global Variable)**
3. **静态局部变量 (Static Local Variable)**

### 2.1 局部变量

在C语言中，**局部变量就是在函数当中定义的变量**，它最主要的特点就是只在声明它的"{}"内部有效。

操作系统为每个执行的C程序（进程）分配虚拟内存空间，局部变量存储在一片被称之为"栈（stack）"的内存区域。

栈的工作原理是**后进先出**，这意味着最后放入栈的项是第一个被移除的。

在C程序的运行过程中，每当一个函数被调用，系统会为其创建一个**“栈帧”**来存储该函数的执行上下文，并将这个栈帧压入栈顶，这个过程称为**函数进栈（push）**。一个函数被调用，就是函数栈帧进栈的的过程。

栈帧中会存储此函数的局部变量（包括形式参数）。

当函数开始执行，对应的栈帧被压入栈顶时，局部变量得以初始化并生效。随着函数执行完毕，栈帧从栈顶中弹出，此时，函数内的局部变量也随之被销毁，这个过程称为**函数出栈（pop）**。

所以局部变量的生命周期与包含它们的函数的生命周期是一致的：

1. 当函数被调用时，其局部变量被创建；
2. 当函数返回时，这些变量被销毁。

在C语言当中，这种**"依托于变量存储空间单元存在而存在"**的变量生命周期形式被称为**"自动存储期限"**。局部变量的自动存储期限，依赖于函数调用栈。

C语言的局部变量没有自动的初始化机制，如果一个局部变量仅有声明没有手动初始化（赋值），那么此局部变量的初始值是未定义的，它的值可以是任意的、随机的"垃圾值"。

使用未初始化的局部变量可能导致程序行为的不确定性和不可预测性。因此，为了保证程序的稳定性和预测性，最佳实践是始终在使用变量之前对其进行初始化。

### 2.2 全局变量

在C语言中，全局变量也是一种特别常见的变量类型，有时它也被称为外部变量。

这是因为它们**在函数之外被定义**，并且**可以在整个文件内，甚至其他文件中（通过外部链接）被访问和使用。**

局变量被存储在虚拟内存空间当中，一片被称之为**"数据段"**的内存区域当中。

不同于局部变量随着函数的调用和返回被创建和销毁，**全局变量的生命周期从程序开始执行时开始，持续到程序完全结束。**

**简而言之，全局变量与程序的生命周期同步：它们在程序开始时被创建并初始化，并在程序结束时被销毁。**

在C语言中，这种持续存在于程序整个执行周期的生命周期特性被称为**“静态存储期限”**。

**全局变量的作用域从"声明位置"开始，并延申至整个程序。**具体来说：

1. 在定义全局变量的文件内，全局变量可以在其声明之后的任何位置被访问和修改。
2. 要想在其他源文件中使用该全局变量，可以通过**extern关键字**来引用它。

关于跨文件调用函数，一般步骤如下：

1. 在一个头文件中**声明**你想跨文件调用的函数。
2. 在一个源文件中包含头文件，然后**定义**这个函数。（包含自定义头文件，使用**#include "xx.h"**）
3. 在另一个源文件中，包含头文件并**直接调用**该函数。

static修饰的全局变量的主要效果是将其**作用域限制在声明它的文件中**，这意味着该变量只能在它所在的源文件中被访问和修改。其它的特性，如生命周期、初始化方式和存储位置，与普通的全局变量是相同的。

比如上面的global_num全局变量，一旦使用static关键字修饰，再次运行程序，就会产生链接错误。因为此时的全局变量已经不能被链接到外部使用了。

### 2.3 静态局部变量

静态局部变量的存储位置和生命周期和全局变量是一致的：

1. 都是存储在数据段区域当中。
2. 生命周期都是从程序启动到程序结束，都是"静态存储期限"。

这就意味着，静态局部变量与一般的局部变量不同：

**静态局部变量不会随着函数的返回而销毁，它会始终保留到程序执行完毕。**

不要将静态局部变量理解成"活得更长"的局部变量，局部变量和静态局部变量在初始化方面有非常大的区别。

**静态局部变量的初始化特性**：

1. **默认初始化**：如果不显式地为静态局部变量提供一个初始值，系统会默认将其初始化为0值。
2. **初始化只有一次**：静态局部变量只会在其所在函数，第一次被调用时初始化一次。此后，不论调用几次该函数，都不会再次初始化了。

静态局部变量的作用域仅限于其所在的函数。这意味着：

**尽管静态局部变量的生命周期与程序的整个执行期间一致，但它只能在定义它的函数内部被访问。**

## 3.递归

**一个函数直接或间接地调用自己，我们称这种现象为“递归”。简而言之，递归是一种函数自调用的行为。**

除此之外，我们还可"抠字眼"来理解递归，将递归分为"递"和"归"两部分：

递：“递”意味着“递推”，即将一个较大规模的问题逐步分解成较小的、更容易处理的子问题。

归："归"意味着"返回"或"回归"，当我们解决了这些子问题后，会从最底层开始，逐步合并或组合这些子问题的答案，直至得出最初问题的解答。

这种“递推-回归”的思维模式是递归的核心，也是其强大之处。

**递归三要素：**

1. **递归体（体现“递”过程）：**
   1. 函数内部递归调用自身的部分。
   2. 递归体是递归思维的核心：它表示如何将一个大规模问题“递推”为较小、相似的子问题。这一分解过程持续地缩小问题规模，以便更容易处理。
2. **递归的出口（体现“归”过程）：**
   1. 当子问题已经足够小或满足某种条件时，我们不再继续分解，而是开始返回答案。这些条件或情况就是递归的出口。
   2. 明确的递归出口是至关重要的。没有明确的出口，递归可能无限进行，直到耗尽资源并导致栈溢出。通过递归的出口，我们实现了从“递”到“归”的转换，开始逐步合并或组合子问题的答案。
3. **递归的深度：**
   1. 每次递归调用都会加深调用的层次，这可以被看作是递归“递”的深度。
   2. 控制递归深度是至关重要的，因为一个过深的递归不仅会增加计算复杂性，还可能导致栈溢出。合理的深度能确保我们在“递”的过程中不会过分深入，同时在“归”的过程中能够有效地返回和组合答案。

例子：递归求解前n个自然数的累加。

![image-20241017173039027](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017173039027.png)

1. **递归体**："return n + sum(n-1); "

   这里的递归体体现了将大问题（如求1到n的和）分解为小问题（求1到n-1的和）的思想。对小问题的求解建立在更小问题的基础上，形成一个递归链条。

2. **递归出口**："if (n == 1) { return 1; } "

   当n值为1时，函数返回1而不再递归调用自身。这是递归的终止条件，确保了递归有一个明确的结束点。

3. **递归深度**： 对于这个函数，递归深度与输入的num值有关。

   例如，当我们调用sum(5)，递归深度为5，因为从sum(5)开始，会连续调用sum(4), sum(3), sum(2), 和sum(1)。每一次调用都会在栈上增加一个新的函数调用帧。

   如果不断增大n的值，递归深度也会增加，这可能导致效率下降，甚至在极端情况下出现栈溢出。

### 3.1 汉诺塔问题

首先看一下汉诺塔问题的描述：

相传在古印度的圣庙中，有一种被称之为汉诺塔（也叫河内塔）的游戏。

简单来说：有三个塔1，2，3，塔1上有 N 个（N>=1）穿孔圆盘，大盘在下，小盘在上。

要求按下列规则将所有圆盘移至塔3：

1. 每次只能移动一个圆盘。
2. 任何时候，大圆盘都不能放在小圆盘的上面。

提示：可将圆盘临时置于塔2，也可以将塔1的圆盘重新移回塔1，但都必须遵循上述两条规则。

问：当塔1上有N（N>=1）个圆盘时，最少要移动多少次？（注意是最少）



**如果选择递归解法，那就思考分解问题，大规模问题化成小规模，分析如下：**：

先来玩三把（N<=3）的汉诺塔游戏：

1. 当N = 1时，直接把盘子从塔1到塔3，仅需1步。**（这就可以作为递归出口）**
2. 当N=2时，先把小盘子移到塔2，再把大盘子移到塔3，最后把小盘子放入塔3，共3步。
3. 当N=3时，先把最小的盘子移到塔3，再把中间的盘子移到塔2。
   1. 然后把最小的盘子移到塔2，最大的盘子移到塔3
   2. 随后最小的盘子移到塔1，中间的盘子移到塔3，最小的盘子移到塔3，共7步

对于N个盘子的汉诺塔问题，我们假设至少需要f(N)步来完成，这f(N)步可以做以下分解：

1. 将前n-1个圆盘从**塔1**移动到**塔2**，此过程需要塔3作为辅助。 **这一步就是把N-1个盘子从一个塔移到另一个塔，共需要f(N-1)步。**
2. 将最大的1个盘子，从**塔1**移动到**塔3**。 **共需要1步完成。**
3. 再将将前n-1个圆盘从**塔2**移动到**塔3**。**这一步就是把N-1个盘子从一个塔移到另一个塔，共需要f(N-1)步。**

于是我们就分解了N个盘子的汉诺塔问题：

**f(N) = f(N-1) + 1 + f(N-1) = 2 \* f(N-1) + 1，这就是递归体。**

找到递归出口和递归体，递归就可以写出来了。

![image-20241017191920199](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017191920199.png)

![image-20241017191929205](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017191929205.png)

![image-20241017191942390](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241017191942390.png)

# 三、指针

![指针变量-示意图](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20240516090057610.png)

## 1.数组名和指针

**数组名是一个代表数组在内存中起始地址的标识符，在大多数上下文中，数组名可以被视为指向首元素的指针。**

进一步解释：

1. **从功能上看，数组名的行为类似于一个固定指向首元素地址的，不可改变指向的指针。**
2. 从语义上讲，数组名代表的是整个数组，而不仅仅是地址。

例如，声明了一个数组**"int arr[5]"**时，数组名arr就代表了这个数组在内存中的起始地址（也就是首元素地址），而且不可被修改。

以下是一些常见的场景，其中数组名会被当作指向首元素的指针使用：

1. 数组名可以直接用于初始化一个指针变量，此时的数组名就当成首元素的指针使用。

   ```c
   arr = NULL;     // 报错
   arr = { 2 };    // 报错
   ```

2. 当一个数组作为参数传给一个函数时，数组名**隐式转换（也称退化）**为指向其首元素的指针。

3. 数组名可以直接进行指针算术运算，此时的数组名就当成首元素的指针使用。

**作为参数传递时，数组名会退化为首元素的指针，为什么叫退化呢？**

之所叫退化，而不是进化，主要原因是：

1. **信息丢失**：**数组在传递时失去了其数组长度的信息。**例如，如果你有一个大小为10的数组，当它被传递到函数时，函数不再知道它的长度。
2. **语义变化**：在数组没有传入函数时，它代表整个数组。但在函数内部，该名称只是一个指针，只代表数组的第一个元素。这是一个从"更丰富"到"更简单"的转变，所以用“退化”这个词来描述是恰当的。

**总之，我们讲数组“退化”为指针，主要是指在传递数组时丢失了其原有属性，而只保留了最基本的，即首元素的地址。**



虽然在许多场合，数组名表现得像指向其首元素的指针，但在某些场景中，将数组名当作指针是不恰当的。

以下是这些特定场景的说明：

**&取地址运算。**

在做取地址运算时，数组名代表整个数组，而不是首元素的指针。也就是说对数组名取地址，就是对数组变量取地址，得到的是代表整个数组的地址。

当然，变量的地址是变量内存空间的第一个字节的内存地址，对于数组而言就是首元素的地址。

也就是说：

数组名在视为指针时，和对数组名取地址得到的结果值是一样的，都是存储数组首元素地址的指针。但很明显，这两个指针的类型以及含义是截然不同的！！

以一个类型为`int[5]`，即长度为5的int数组为例：

1. 数组名视为指针时，存储的是首元素的地址，指向数组首元素。数组名作为指针时的类型是`int *`类型。
2. 对数组名取地址时，得到的是整个数组变量的地址，虽然从地址值上它还是指向数组首元素，但类型变成了`int[5] *`。这个指针指向的是整个数组变量，而不是数组首元素。

![image-20241022180746979](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241022180746979.png)

## 2.数组指针和指针数组

数组指针" 和 "指针数组" 是两种完全不同的概念：

1. 数组指针是一个实际开发中比较罕见的语法，了解即可。
2. **指针数组则比较重要，也比较常用。**

**数组指针（Pointer to an Array）**

**定义：数组指针是一个指针，它是一个指向整个数组的指针。**

**声明：**例如，要声明一个指向包含5个整数元素的数组的指针，你可以这样做：

```c
int arr[5];
int (*ptr_to_arr)[5] = &arr;  // ptr_to_arr 是一个指向包含5个整数的数组的指针
```

数组指针声明的语法中，非常关键的就是"**(\*指针名)**"，一定要加上小括号，你知道为什么吗？

实际上是因取下标运算符(`[]`)的优先级高于解引用运算符(`*`)，不加小括号整体就是一个数组即指针数组，而不是数组指针。

**用途：**

数组指针通常在函数参数中用来指向和传递二维数组。但一来二维数组比较少用，二来就算要用二维数组传参，直接按下面的写法就可以了：

```c
// 二维数组作为形参时，必须指定列数，行数则不需要指定
void process_matrix(int (*matrix)[5], int rows) {
}
// 等价于
void process_matrix(int matrix[][5], int rows) {
}
```

**指针数组（Array of Pointers）**

**定义：**指针数组是一个数组，它是一个元素都是指针变量的数组。**

**声明：**

例如，要声明一个包含5个整数指针元素的数组，你可以这样做：

```c
// ptr_arr和ptr_arr2是可以装5个int*类型指针元素的数组
int *ptr_arr[5] = { 0 };  //全部初始化为空指针

int a = 1, b = 2, c = 3, d = 4, e = 5;
int *ptr_arr2[5] = {&a, &b, &c, &d, &e};  // 用指针变量进行初始化
```

**用途：**

指针数组最常见的用途就是存储字符串数组。除此之外，它们还在多种数据结构中发挥重要作用，例如函数指针数组、动态数据结构等。

3.常量指针和指针常量

**常量指针 (Constant Pointer)**

**含义：指针本身是一个常量，指针无法指向一个新的对象。但可以利用该指针修改指向的对象！**

定义形式：

```c
int a = 10;
int b = 20;
// p指针是一个常量,它无法指向新的对象,但利用该指针可以修改指向的对象
int* const p = &a;  // const修饰的是指针p，所以指针p本身是一个常量
*p = 30;
// p = &b; error
```

建议：

我不建议在任何场景下，直接提"常量指针"四个字，因为这四个字实在无法描述语法本来的含义。当你看到**"类型\* const 指针名"**这样的语法时：

1. 你可以直白的用中文讲"const修饰指针，指针本身是一个常量，无法修改指针的指向"。
2. 你也可以直接提它的英语单词"Constant Pointer"（不可变的指针）。

**指针常量 (Pointer to Constant)**

**含义：无法利用指针修改指向的内容，但指针本身可以指向不同的对象。**

定义形式：

```c
int a = 10;
int b = 20;

// 无法使用指针p修改变量a的取值,但该指针可以指向新的对象
const int* p = &a;  // 也可以用"int const *p"; 此时const修饰的*p，也就是指针指向的对象是一个常量
//*p = 30; error
p = &b;
```

**不要将"指针常量"语法理解成指向一个常量的指针，实际上该语法只意味着"无法利用该指针修改指向的内容"，指针指向的实际是一个变量也完全可以。**

建议：

我不建议在任何场景下，直接提"指针常量"四个字，因为这四个字实在无法描述语法本来的含义。当你看到**"const 类型\* 指针名"**这样的语法时：

1. 你可以直接用中文讲"这是一个无法修改指向内容的指针"
2. 也可以记住它的英文单词"Pointer to Constant"

## 3.指针算术运算

指针常见的，能够进行的算术运算包括：

1. 指针加整数。
2. 指针减整数。
3. 指针自增和自减（本质还是加减整数）
4. 两个指针相减。
5. 指针比较。

**指针算术运算并不仅仅是为数组设计的，但在实际应用中，指针算术运算最经常与数组结合使用。**

以下是指针算术运算的一些限制和注意事项：

1. 两个指针之间可以做减法，但不能做加法，指针也不能做乘除运算。
2. 进行算术运算前，要确保指针不是野指针。（要将指针进行正确的初始化）
3. 如果不确信指针是否为NULL，最好先判NULL。
4. **只有指向同一个数组或连续的内存块的两个指针才可以被相减。**
5. **不同类型的指针不要做算术运算。**
6. **对数组的指针进行算术操作时，应确保操作后的指针仍然指向数组的元素，一旦超出数组的内存界限，即产生野指针。**

### 3.1 两个指针相减

**两个指针相减的前提是它们必须指向同一个数组(或连续内存块)，否则会产生未定义行为。**

```c
p = &arr[5];
q = &arr[1];
int i;
i = p - q;  /* i = 4  */
i = q - p;  /* i = -4 */
```

### 3.2 关系运算（<、 <=、 >、 >=）

关系运算是比较什么呢？

其实比较的就是指针中存储的地址值的大小。如果p1指向的地址，小于p2指向的地址，则p1 < p2为真。

一般而言，这个比较是没太大意义的。但是在使用数组的上下文中，是比较有用的：

**因为数组元素在连续的内存地址中存储。所以，如果两个指针都指向同一个数组的不同元素，可以使用关系运算来确定哪个指针指向的元素在数组中的位置更前。**

# 四、字符串

## 1.字符串字面值

字符串字面值被存储在只读数据段中，这意味着字符串字面值有以下特点：

1. 不可变、只读性。
2. 静态存储期限，生命周期与程序的整个执行时间相同。（数据段内存储的数据都具有静态存储期限）

总之，字符串字面值本质上就是一个存储在只读数据段当中的字符数组。注意：

**所有的字符串都是以终止字符'\0'结尾的字符数组，但并不是所有的字符数组都可以视为有效的字符串。**

### 1.1 字符串字面值的操作

**字符串字面值在代码中的大多数场景下，可以直接视为一个字符数组的数组名使用，也就是视为字符数组的首元素指针去使用。比如你可以写出下面的代码：**

```c
// char_arr = NULL; // 数组名不可赋值 ERROR
// "hello" = NULL;  // 类似数组名不可赋值 ERROR
"hello"[4] = '1';   // 可读但不可写 运行该代码会导致未定义行为 ERROR
```

### 1.2 字符串字面值索引运算的惯用法

字符串字面值可以直接进行索引运算，从而获取对应位置的字符。这种用法并不多见，但是在某些场景下有奇效。

下面这个问题，就是经典场景之一：

定义一个函数，将传入的 0 ~ 15 十进制数转换成十六进制的字符形式。

那么这个函数就可以按照如下定义：

```c
char digit_to_hex_char(int digit) {
  return "0123456789ABCDEF"[digit];
}
```

## 2.字符串变量

```c
/*
* 这里的"hello"不应理解成一个存储在只读数据段中的字符串字面值
* 在这里"hello"不应被视为数组名
* 而应该理解为:
* 字符数组初始化式 {'h', 'e', 'l', 'l', 'o', '\0'}的简写形式
* 本质上是一个语法糖
* 此时该字符数组的长度是6,存储的内容是:
* {'h', 'e', 'l', 'l', 'o', '\0'}
*/ 
char str[] = "hello";
// 上述代码等价于
char str2[] = {'h', 'e', 'l', 'l', 'o', '\0'};
```

特别需要注意的是：

**千万不要认为str数组是引用了字符串字面值"hello"数组！！！**

实际上这里会创建一个全新的str数组，然后将"hello"的字符信息复制进去，再追加一个空字符。

### 2.1 字符串变量和字符串字面值的对比

```c
// main:
char str[] = "Showmaker";
char *p = "Showmaker";
```

它们的区别在于：

1. str是一个字符串变量，同时也是一个字符数组。
   1. 此初始化代码中，"Showmaker"是一个初始化式的简写形式，不应将它理解成一个字符串字面值。
   2. str数组是一个在栈上创建的独立的新数组，借助"Showmaker"这个初始化式，完成初始化。
   3. **此字符数组表示的字符串内容以及整个字符数组元素，都是完全可变的！**
2. p是一个指向字符的指针变量。
   1. 此时"Showmaker"就需要理解成字符串字面值。
   2. p指针指向的是只读数据段中，存储字符串字面值的字符数组的首元素地址。
   3. **字符串字面值是不可变的！**意味着指针p，是一个可以改变指向，但不能改变指向内容的指针。

![image-20241028200232993](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241028200232993.png)

总之，如果你需要一个可以修改内容的字符串，那么就需要主动声明初始化一个字符数组来存放该字符串，也就是字符串变量。

## 3. C语言字符串库

C 语言中的字符串处理与其他高级编程语言有所不同。在许多编程语言中，字符串被当作一个独立的类型，并提供了一套丰富的运算符来操作这些字符串，如复制、比较和拼接。

但在C语言中，字符串实际上就是以空字符'\0'结束的字符数组。**这意味着常规的C运算符不能直接用于字符串操作。**

举例说明，下面的代码中尝试使用一些运算符来操作字符串，但实际上都是不可行的：

```c
char str1[10], str2[10];

str1 = "abc";    // 错误: 不能直接为字符数组赋值
str2 = str1;    // 错误: 不能直接复制字符数组

if (str1 == str2)  // 这样的比较是比较两个指针的地址，而不是字符串的内容。这个比较通常是没有什么意义的
```

### 3.1 strlen获取字符串长度

### 3.2 strcpy字符串复制

更安全的字符串复制函数strncpy

**char *strncpy(char *dest, const char *src, size_t n);**

该函数会将最多n个字符从src中复制到dest数组中

### 3.3 strcat字符串拼接

更安全的字符串拼接函数strncat函数

**char *strncat(char *dest, const char *src, size_t n);**

该函数的行为是：

仍旧是找到dest字符串末尾的空字符，然后从该字符开始，将 src 的首个元素复制到 dest末尾，直到：

1. 已经复制了 n 个字符。
2. 或者复制到达了`src`字符串的结尾，即遇到了`src`的空字符串。所以该函数不会把src中的空字符复制到dest中。

### 3.4 strcmp字符串比较大小

### 3.5 字符相关的库函数

 C 标准函数库在**头文件 <ctype.h>** 中定义了大量此类功能函数。比如：

**islower 和 isupper** 函数是 C 标准库中声明在 <ctype.h> 头文件中的函数，它们用于检查给定的字符是否为小写字母或大写字母。

1. islower(int c) 检查传入的字符 c 是否为小写字母（a 到 z）。如果是，函数返回非零值（真），如果不是，返回零（假）。
2. isupper(int c) 检查传入的字符 c 是否为大写字母（A 到 Z）。如果是，函数返回非零值（真），如果不是，返回零（假）。

除此之外，<ctype.h> 头文件中还包括了以下类似的库函数：

1. `isalpha(int c)`：检查传入的字符是否为字母（包括大写和小写）。
2. `isdigit(int c)`：检查传入的字符是否为十进制数字（0到9）。
3. `isalnum(int c)`：检查传入的字符是否为字母或数字。
4. `isspace(int c)`：检查传入的字符是否为空白字符，比如空格、制表符、换行符等。
5. `isblank(int c)`：检查传入的字符是否为空格或制表符。

## 4. 字符串数组

字符串的本质是一个字符数组，那么存储字符串的数组就是一个字符数组的数组，也就是字符二维数组。这种方式是存储字符串集合最容易想到的方式。

比如定义一个用字符二维数组，存储星期天数名称的字符串集合：

```c
char week_days[][10] = 
    { "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday" };
```

![image-20241028204747914](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241028204747914.png)

这种做法简单直观，但有两个比较大的缺点：

1. 空间浪费。比如，上图中红色的空字符都是多余的，但这些空间没有办法利用。
2. 不够灵活也效率低下。比如，需要对一组字符串进行排序，可能就需要复制交换整个字符串里面的内容。

所以在更多的时候我们会选择用**字符指针数组**来存储字符串集合。

字符指针数组，也就是存储字符指针变量的数组，通过存储一个字符串字符数组的首元素指针变量，进而存储一个字符串集合。

比如定义一个用字符指针数组，存储星期天数名称的字符串集合：

```c
char* week_days[] =
    { "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday" };
```

![image-20241028204819117](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241028204819117.png)

而且它们还有一个在操作和使用上的区别：

1. `char week_days[][10]`的形式会在栈上(局部变量)分配空间，用一段连续的内存空间来保存多个字符串，此字符串数组的内容是可以修改的。
2. `char* week_days[]`的形式是一个字符指针数组，由于使用字符串字面值进行初始化，那么这些字符指针都会指向只读数据段中的字符串字面值的字符数组，所以此字符串数组的内容是不可以修改的。

```c
char week_days[][10] =
{ "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday" };

week_days[1][3] = 'a';      // 允许修改，代码正常运行，而且修改可以成功

char *week_days2[] =
{ "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday" };
week_days2[1][3] = 'a';     // 不允许修改，未定义行为，一般会导致程序崩溃
```

## 5.命令行参数

在C语言中，字符指针数组常常用来处理和存储多个字符串，比较常见的场景就是——**命令行参数处理**。

所谓命令行参数，可以这样理解：

**当你在命令行中启动一个C程序时，你在指令输入窗口输入的文本（即命令行参数）就由操作系统接收。操作系统再将这些参数解析为一个字符串数组，并在启动程序时传递给这个C程序。**

所以命令行参数的传递过程，实际上是下面的流程：

1. 用户在命令行中启动C程序，传递给操作系统一个命令行参数字符串
2. 然后由操作系统解析这个字符串，解析成一个字符串数组
3. 最后操作系统启动C程序时，将字符串数组传递给这个C程序

C程序若希望接收命令行参数字符串数组，则需要把main函数声明为：

```c
int main(int argc, char *argv[]);
```

操作系统接收到用户输入的命令行参数字符串后，会以空格为间隔，来分割每一个命令行参数，将用户输入的命令行字符串解析成一个字符串数组。

比如接收的命令行参数字符串是：`./main test test2`

最终就会解析成字符数组：["./main", "test", "test2"]

一个命令行参数使用的演示代码：

```c
// main函数通过命令行参数接收数据，参数argc和argv由操作系统提供。
int main(int argc, char * argv[]){  
    // argc = argument count 表示命令行参数的个数，至少为1个。你可以将该参数理解成数组的长度
    // argv = argument vector 表示要传参的字符串数组，这里是用一个字符指针数组来存储字符串集合

    // 在main函数中就可以操作命令行参数
    printf("argument count = %d\n", argc);

    // 遍历argv字符串数组，打印每一个字符串
    for (int i = 0; i < argc; i++) {
        printf("第%d个参数是：%s\n", (i + 1), argv[i]);
    }

    // main函数返回给操作系统的值，这个值就是状态码
    return 0;
}       
```

### 5.1 如何把获取的命令行参数转换成其它类型呢？

操作系统在给main函数传参时，参数的类型始终是字符串。若想将字符串转换成其它类型，可以考虑使用**sscanf函数**。

scanf函数表示从stdin缓冲区中读取字符数据，并以"格式字符串"表示的形式转换成各种类型。类似的：

sscanf即，`string scanf`表示从字符串(字符串数组)中读取字符数据，并并以"格式字符串"表示的形式转换成各种类型。

一个简单的演示如下：

```c
// 假设第二个传参是100,需要将它转换成int类型
int num;
sscanf(argv[1], "%d", &num);
```

# 五、结构体

结构体变量主要可以进行的操作有：

1. 访问/修改结构体成员
2. 结构体变量给结构体变量赋值
3. 结构体变量作为参数传递
4. 结构体变量作为函数返回值

下面我们以上面定义的结构体Student，来演示一下结构体对象的这些基本操作。

**结构体对象和数组变量的区别**

数组作为形参时直接退化成指针，灵活的同时避免了大量数据复制损耗性能，而且C语言不允许数组类型直接做返回值类型，而是只能返回指针类型间接返回一个数组。

但结构体完全不同：

1. 当结构体变量作为函数的参数传递时，会将整个结构体复制拷贝一份，然后传递到函数体内部。
2. 当结构体变量作为函数的返回值时，函数调用者接收返回值意味着，要将整个结构体对象复制一份。

这样会增加程序的开销，特别是当结构体很大的时候。**为了避免这些不必要开销，我们可以传递或返回一个指向结构体的指针。**

# 六、指针的高级应用

## 1.存储期限

在C语言中，根据数据在虚拟内存空间中的生命周期和位置，可以划分为以下三种主要的存储期限：

1. **自动存储期限：**
   1. 数据存储在栈（Stack）上，主要指函数内部定义的局部变量，包含函数内部定义的数组和结构体。
   2. 这些变量在对应函数被调用时分配内存空间，并在函数返回时随着栈帧的出栈而销毁。
   3. 自动存储期限意味着，变量只在声明它们的函数调用期间生效。
2. **静态存储期限：**
   1. 数据存储在数据段中，主要指全局变量、静态局部变量以及static修饰的全局变量。
   2. 字符串字面值也是静态存储期限，存储在数据段的只读区域。
   3. 这些数据在程序启动时初始化，并在整个程序运行期间持续存在，直到程序结束。
3. **动态存储期限：**
   1. 数据存储在堆（Heap）上，由程序员在运行时手动申请空间，分配空间创建的变量具有动态存储期限。
   2. 动态存储期限意味着由程序员手动控制生命周期，手动分配内存，手动释放内存。

这三种存储期限反映了不同类型的数据在内存中的管理方式和生命周期，是C语言内存管理的基础。理解这些概念对于编写高效、稳定且易于维护的程序至关重要。

## 2.栈区的内存管理及其特点

栈区域的内存管理主要依赖**栈指针寄存器(Stack Pointer寄存器，简称SP寄存器)**的移动来完成。

可以简单把SP寄存器看成是一个跟踪栈顶位置的指针，它始终指向栈的顶部。

栈区域可以随着函数调用生长，而且是从高地址向低地址，向下生长，所以：

1. 当函数开始调用，栈帧进栈时，SP会减少，栈顶移向低地址。
2. 当函数调用结束，栈帧出栈销毁时，SP会增加，栈顶移向高地址。

![栈区的内存管理-进栈](https://tonve2.oss-cn-shanghai.aliyuncs.com/202311082026062.png)

![栈区的内存管理-出栈](https://tonve2.oss-cn-shanghai.aliyuncs.com/202311082026358.png)

缺点：

1. 大小非常有限。为了保障栈区的性能，避免空间浪费，栈区域的大小非常小，一般只有几MB。栈区是比较容易出现内存溢出错误的内存区域。
2. 线程安全但也意味着线程间不同共享栈区数据。
3. 为了通过SP寄存器的加减就能够管理栈区域，程序在编译时期就必须确定栈帧的大小。这意味着栈区域存储的数据，必须在编译时期确定它的大小。**栈区域一般不能存放运行时才能确定大小的数据。**

依据以上缺点，以下这些数据就无法直接存储在栈区域了：

1. 过大的数据。比如很长的数据，字符串，很大的结构体。
2. 多个线程间需要共享的数据。
3. 在程序运行时期，需要动态分配内存空间的数据。

## 3.堆区的内存管理及其特点

当栈区无法完成任务，比如以下场景，堆空间的使用就是必须的：

1. 存储体积较大的数据结构，如大数组、长字符串和大型结构体。
2. 动态数据结构。如动态长度的数组，链表，树等。
3. 多线程共享的数据。
4. **需要作为函数返回值的数据结构的指针。（返回栈区数据的指针会引发悬空指针问题）**

## 4.内存分配函数malloc

该函数的声明是：`void* malloc(size_t size);`

注意：

1. **此函数会在堆空间上分配一片连续的，size个字节大小的内存块**
2. **此函数不会对内存块中的数据进行初始化，内存块中的数据是随机未定义的。**
3. 如果分配成功，此函数会返回指向该**内存块地址(首字节地址)**的指针。**注意返回的指针类型是void指针，在操作之前需要进行转换。**
4. 如果分配失败，此函数会返回一个空指针(NULL)

总结：

1. **正确传参free函数。**free函数需要传入指向动态分配内存块首字节的指针，free之前不妨检查指针是否已被移动。
2. **在free内存块后，建议立刻将指针设置为NULL。**这样可以规避一些常见的问题：
   1. 避免了"double free"的风险。对空指针调用`free函数`是安全的，它不会有任何效果。
   2. 减少悬空指针出现的风险。解引用空指针导致程序崩溃，比悬空指针带来的未定义行为要更容易检测和修正。
3. **慎重改变堆区指针的指向。**指向堆区域的指针，如果需要改变它的指向，在改变之前应当考虑指向的内存块是否需要free。
4. **多函数共同管理同一块内存区域时，应严格遵循单一原则。**尤其是，哪个函数用于分配内存，哪个函数用于free释放内存，这两个函数一定要明确单一的职责。
