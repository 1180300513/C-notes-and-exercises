**编译（Compilation）**：

- **过程**：将每个 `.c` 源文件分别编译成对应的目标文件（通常是 `.o` 或 `.obj` 文件）。
- 检查内容：
  - 语法错误、语义错误。
  - 确保所有使用的函数在当前编译单元中有声明（通常通过包含头文件）。
  - 但编译器不会检查这些声明的函数在其他源文件中是否有具体的实现。

**链接（Linking）**：

- **过程**：将所有目标文件以及必要的库文件合并成一个可执行文件。
- 检查内容：
  - 确保所有外部引用（即在一个源文件中声明但在其他地方定义的函数或变量）都有对应的定义。
  - 解决函数和变量的地址，以便程序能够正确地调用和访问它们。

**编译器的角色**：

- 编译器在编译每个源文件时，确保所有使用的函数和变量都有相应的声明。
- 但编译器不会验证这些声明是否在其他源文件中有对应的定义。这一验证留给链接器完成。

**链接器的职责:**

- **解析外部引用**：
  - 链接器会扫描所有目标文件和库文件，查找所有声明的函数和变量的具体定义。
  - 如果发现某个声明没有对应的定义，链接器会报错。
- **符号重整（Name Mangling）问题**（尤其在C++中）：C++的函数名会经过重整，如果C和C++混合编程，可能需要使用 `extern "C"` 来避免。

**编译器和链接器的互动**

- **编译阶段**：
  - 编译器将每个源文件转换为目标文件，并记录所有外部引用（需要链接的函数和变量）。
  - 这些外部引用在目标文件中以符号的形式存在，但尚未绑定到具体的地址。
- **链接阶段**：
  - 链接器读取所有目标文件和库文件，解析符号并绑定它们到具体的地址。
  - 如果所有符号都能成功解析，链接器生成最终的可执行文件。
  - 如果有未解析的符号，链接器报错，阻止生成不完整或无法执行的程序。

**为什么程序会同时要求提供lib和dll？**

- **lib文件的作用**：在编译期间，lib文件会作为链接器的参考，告诉链接器所需函数的定义位置。这个lib文件本质上是一个“索引”，它指示链接器在哪些动态链接库（dll）中可以找到所需的函数实现。因此，lib文件用于提供编译期的符号信息，帮助生成可执行文件。
- **dll文件的作用**：在运行时，程序实际需要的函数实现存在于dll文件中。也就是说，虽然lib文件在编译时提供了符号引用，但是函数的具体实现是在dll文件里，当程序运行时，这些实现才会被加载和执行。

# 基础知识补充

## 1.基本输入输出

### 1.1 缓冲区

> 冯诺依曼体系计算机（也叫存储程序控制型计算机），主要包含三大核心组件：**CPU、IO设备以及存储器**，而存储器当中最重要的则是内存储器，也就是**内存**。
>
> 直到今天，硬件设备的发展日新月异，但现代计算机仍没有脱离此体系。
>
> 冯诺依曼体系计算机，一个核心问题是CPU、内存以及IO设备三者之间的速度差异从而导致的性能瓶颈，这就是常说的"冯·诺依曼瓶颈”。
>
> 具体的说，这个瓶颈指的是：
>
> CPU 的处理速度远远快于内存和 I/O 设备，导致在等待数据处理和传输时，CPU 大部分时间处于空闲等待的状态。这种速度差异造成了显著的性能瓶颈，限制了整个系统的效率。
>
> 为了平衡这三者之间的速度鸿沟，一个简单有效的手段是引入**缓冲区**技术，下面我们简单介绍一下缓冲区技术。

**缓冲区本质上是一块临时存储数据的内存区域(一般是在内存中分配的)，它在速度较慢的内存和 I/O 设备与速度较快的 CPU 之间起到桥梁的作用。**

为了更深入地解释缓冲的工作原理，以`printf`和`scanf`函数为例，可以更直观地解释其运作机制：

1. 当你使用 `printf` 输出数据时，数据并不是立刻写入到输出设备（如屏幕）。它首先被放置在一个**stdout缓冲区**中，然后在满足特定条件时，数据会被刷新到输出设备。
2. 当你使用 `scanf` 输入数据时，数据也不是直接从输入设备（如键盘）读取的。它首先被加载到一个**stdin缓冲区**中，然后 `scanf` 从这个缓冲区中获取数据。

![格式化输入输出-缓存模型](https://tonve2.oss-cn-shanghai.aliyuncs.com/202310100939887.png)

**缓冲区的优点**：提高IO性能

我们都知道，I/O的过程效率很低。除了硬件性能本身的差异外，I/O操作的复杂性也是非常重要因素。每次进行I/O操作都会带来一些固定的开销，比如：

1. 每次 I/O 操作都需要设备初始化和响应等待等。
2. 操作系统管理 I/O 请求，涉及中断处理和上下文切换，这些都消耗了大量时间。
3. 应用从用户态切换到内核态的系统调用也会带来额外的时间开销。（I/O操作普遍涉及系统调用）
4. ....

总之，如果每输入或输出一个字符都要进行一次完整的I/O操作，那么这些固定的开销就会迅速积累，导致性能显著下降。

硬件层面的效率低下，我们没有办法通过软件层面的优化去解决。但对于这些大量的固定开销，我们可以通过缓冲区来进行效率优化。

缓冲区的主要目的是暂时存储数据，然后在适当的时机一次性进行大量的I/O操作。这样，多个小的I/O请求可以被组合成一个大的请求，有效地分摊了固定开销，并显著提高了总体性能。

从上述内容中，我们可以明确地看到缓冲区的一个显著特点：**当满足特定的条件时，程序会开始对缓冲区内的数据执行输入或输出操作。**

这种**“满足条件即触发数据传输”**的行为，被我们称为**“缓冲区的自动刷新”**机制。

基于这种自动刷新的触发条件的不同，我们可以将常见缓冲区划分为以下三种类型：

1. **全缓冲区，也叫满缓冲区。**顾名思义，仅当缓冲区达到容量上限时，缓冲区才会自动刷新，并开始处理数据。否则，数据会持续积累在缓冲区中直到缓冲区满触发自动刷新。**文件操作的输出缓冲区便是这种类型的经典例子。**
2. **行缓冲区。**缓冲区一旦遇到换行符，缓冲区就会自动刷新，所有数据都会被传输。**stdout缓冲区就是典型的行缓冲区。**
3. **无缓冲区，不缓冲。**在此模式下，数据不经过中间的缓冲步骤，每次的输入或输出操作都会直接执行。这种方法适用于需要快速、实时响应的场合。例如，stderr（标准错误输出）就是这种方式，它经常被用来即时上报错误信息。

**补充和注意事项：**

1. **无论是哪种类型的缓冲区，当缓冲区满了时，都会触发自动刷新。**
   1. **全缓冲区**：唯一的自动刷新条件是缓冲区满。
   2. **行缓冲区**：除了缓冲区满导致的自动刷新，还有遇到换行符的自动刷新机制。
2. 手动刷新。大多数缓冲区提供了手动刷新的机制，比如使用**fflush函数**来刷新stdout缓冲区。
3. **输出缓冲区中的数据需要刷新才能输出到目的地，但输入缓冲区通常不需要刷新，强制刷新输入缓冲区往往会引发未定义行为。**
4. 当程序执行完毕（如main函数返回）时，缓冲区通常会自动刷新，除此之外，还有一些独特的机制也可以刷新缓冲区。但这些机制可能因不同的编译器或平台而异，不能作为常规手段。**强烈建议依赖手动或者常规自动刷新的机制来完成缓冲区的刷新。**
5. 不同的编译器和开发环境可能会对输出缓冲进行特殊设置，尤其是在调试模式下，以便提供更好的调试体验。比如在VS的Debug模式下，即使没有换行符，`printf`函数的输出通常也会立即显示在控制台上。这种行为是为了帮助程序员更有效地调试程序，即时看到他们的输出，而不需要固定等待缓冲区刷新条件。

### 1.2 printf的转换说明

转换说明在`printf`函数中起到了关键的角色，允许开发者对输出格式进行精细的控制。它主要有以下几个作用：

1. 占位符的作用。
2. 控制输出的格式，比如宽度，精度等。
3. **指示被转换成字符数据的对应参数的类型。**

```c
%[标志][字段宽度][.精度][长度]说明符
```

1. "%"是转换说明的开始，必不可省略。

2. **[标志]**用于决定一些特殊的格式，常见的标志有：

   1. **-**：左对齐输出。如果没有该标志，输出默认是右对齐的。
   2. +：输出正负号。对于正数，会输出+，对于负数，会输出-。
   3. 0：当输出宽度大于实际数字的字符数量时，使用0而不是空格来填充。
   4. 空格：当数值为正时，在数值前面添加一个空格，而负数则添加-。如果同时使用了+标志，+标志会覆盖空格标志。

3. **[字段宽度]**用于指定输出的最小字符宽度，但不会导致截断数据：

   1. 如果输出的字符，宽度小于指定的宽度，那么输出的值将会按照指定的**[标志]**来进行填充。若标志位没有0，则会填充空格。
   2. 如果输出的字符，宽度大于指定的宽度，那么printf函数并不会截断，而是完全输出所有字符。

4. **[.精度]**定义打印的精度：

   1. 对于整数，表示要输出的最小位数，若位数不足则左侧填充0。
   2. 对于浮点数，表示要在小数点后面打印的位数。
      - 当有效数字不足时，会自行在后面补0
      - 当有效位数超出时，会截断保留指定的有效位数。这个过程一般会遵守"四舍五入"的原则。
      - **但由于浮点数存储的固有精度问题，某些数值可能不能完美表示，导致结果中的数字稍有偏差。**
      - **注意在不指定[.精度]的情况下，浮点数默认显示6位小数，多的部分舍弃，不够的话，会在后面补0。**

5. **[长度]**主要描述参数的数据类型或大小。常见的长度修饰符有：

   1. **h :** 与整数说明符一起使用，表示short类型。
   2. **l (小写的L):** 通常与整数或浮点数说明符一起使用，表示long（对于整数）或double（对于浮点数）。
   3. **ll (两个小写的L):** 与整数说明符一起使用，表示long long类型的整数。
   4. **L (大写的L):** 与浮点数说明符一起使用，表示long double。

6. **说明符，必不可省略。**描述如何格式化和显示该参数。常见的说明符有：

   1. **d** 或 **i** : 表示有符号的十进制整数。
   2. **u**：表示无符号的十进制整数。
   3. **o**：表示无符号的八进制整数。
   4. **x**：表示无符号的十六进制整数，使用小写字母（例如：`a-f`）。
   5. **X**：表示无符号的十六进制整数，使用大写字母（例如：`A-F`）。
   6. **f**, **e** 或 **E** : 浮点数。
      - **e**：强制用科学计数法显示此浮点数，使用小写的“e”表示10的幂次。
      - **E**: 强制用科学计数法显示此浮点数，使用大写的“E”表示10的幂次。
   7. **g** 或 **G** : 选择最合适的表示方式，浮点数或科学记数法。
      - g，当选择使用科学计数法显示此浮点数时，使用小写的“e”表示10的幂次。
      - G，当选择使用科学计数法显示此浮点数时，使用大写的“E”表示10的幂次。
   8. **c** : 字符。
   9. **s** : 字符串。纯粹打印字符串一般不需要用转换说明，直接使用普通字符输出即可。
   10. **p** : 指针。

   

在转换说明中，有一个非常特殊的字符——"%"。百分号用于转换说明的开始，那么如果我就希望打印一个百分号咋办？

**很简单，用"%%"来表示一个"%"。**

​	![image-20241014185642967](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241014185642967.png)

**转换说明中的特殊符号"*"**

假如给定一个浮点数：

```c
float a = 3.1415926f;
```

希望能够用变量在程序运行时期确定打印小数点后的位数以及打印结果的总宽度，比如给定两个变量：

```c
int width = 5;
int point = 2;
```

![image-20241014190015914](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241014190015914.png)

该语句中的第一个"*"就表示将从`printf`函数的参数列表中动态获取宽度，也就是变量`width`作为宽度。

该语句中的第二个"*"就表示将从`printf`函数的参数列表中动态获取保留小数点位数，也就是变量`point`作为保留小数点位数。

`*`字符的存在，使得转换说明中的具体值可以动态的从函数的参数中获取，给格式字符串的使用带来了极大的灵活性，是一个非常重要的语法。

但是要注意，在scanf中`*`星号具有特殊的含义，不要和printf函数混淆了。

### 1.3 scanf的转换说明

**scanf函数**使用转换说明来解析和读取输入，这为开发者提供了对输入数据格式的精细控制。

系统地讲，**scanf函数**的转换说明的组成公式如下：

```c
%[*][宽度][长度]说明符
```

**其中，"%"和"说明符"是必不可少的，而其他部分则是可选的。我们用[]括起来表示这些可选的部分。**

接下来，我们逐一解释每个组成部分：

1. **"%"：**是转换说明的开始，并且是必不可省略的。
2. **[\*]也称之为赋值抑制：**当使用该符号时，对应的输入会被读取，但不会存储到任何变量中。例如，使用"%*d"意味着会读取一次输入，但此输入完全无效不会赋值到对应变量。
3. **[宽度]：**表示要读取的最大字符数量。例如，"%5d"意味着读取最多5个字符来解析为一个整数。
4. **[长度]：**描述参数的数据类型或大小。常见的长度修饰符有**（和printf函数一致）**：
   1. **h :** 与整数说明符一起使用，表示short类型。
   2. **l (小写的L):** 通常与整数或浮点数说明符一起使用，表示long（对于整数）或double（对于浮点数）。
   3. **ll (两个小写的L):** 与整数说明符一起使用，表示long long类型的整数。
   4. **L (大写的L):** 与浮点数说明符一起使用，表示long double。
5. 说明符：这是必不可少的部分，描述如何解析输入数据。常见的说明符有**（和printf函数一致）**：
   1. **d**: 表示有符号的十进制整数。
   2. **i：注意scanf函数的转换说明`i`和printf的是不同的。** 
      - printf函数的i和d都是等价的，都表示输出有符号的十进制整数。
      - 但**scanf的i会自动判断输入的整数的进制，从而进行不同的录入。支持十进制、八进制、十六进制整数。**
   3. **u**：表示无符号的十进制整数。
   4. **o**：表示无符号的八进制整数。
   5. **x/X:** 表示无符号十六进制整数。
   6. **f, e, E, g, G:** 表示浮点数。
   7. **c:** 表示单字符。
   8. **s：**字符串。会读取连续的字符，直到遇到空白字符（如空格、制表符或换行符）为止。
   9. **p:** 指针。
   10. `%[字符集]`: 这告诉`scanf`只接受和存储来自指定字符集的字符。字符集是直接写在`[`和`]`之间的。例如，`%[abc]`将只读取'a', 'b', 或 'c'字符，其他的字符将导致读取停止。
   11. `%[^字符集]`: 这是扫描集的否定形式，告诉`scanf`接受和存储除了指定字符集之外的所有字符。`^`字符放在`[`之后立即表示否定。例如，`%[^abc]`将读取除了'a', 'b', 和 'c'之外的所有字符，直到遇到这三个字符中的任何一个为止。

**scanf函数**本质上是一个**"模式匹配"**函数，试图把**"stdin缓冲区"**中的字符与格式字符串匹配。

**scanf函数**会从左到右依次匹配格式字符串中的每一项：

1. 如果匹配数据项成功，那么scanf函数会继续处理格式串的剩余部分；
2. **如果匹配不成功，那么scanf函数将不再处理格式串的剩余部分，而会立刻返回。**

![image-20241014194014634](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241014194014634.png)

![image-20241014194123278](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241014194123278.png)

**关于录入字符的特殊性**

**scanf 函数用 %c 格式化字符串来读取单个字符时，并不会跳过空白字符，%c 会读取输入的下一个字符，无论它是什么，包括空白字符。**

所以在录入字符时，尤其是一行录入多个数据且包含输入字符时，一定要在转换说明前面留出一个空格，以匹配可能的空格：

![image-20241014194430099](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241014194430099.png)

## 2.基本数据类型

### 2.1整型

下表是64位处理器，在Linux平台机器上，整数类型的常见取值范围：

![image-20241014201251340](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241014201251340.png)

![image-20241014201825669](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241014201825669.png)

### 2.2 浮点数类型

![image-20241015095236172](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015095236172.png)

1. 表格中给出的大致取值范围是非常不准确的，浮点数存在规格化和非规格化的区别，所以它们的取值范围是不能用连续区间表示的，但为了简单起见就直接这么写了。
2. long double 类型没有显示在此表中，因为它的长度可能随机器的不同而变化，最常见的是 80 位和 128 位。它往往取值范围比 `double` 类型更广，精度也更高。**但某些平台也存在long double等同于double的情况。**

**浮点数的不精确是绝对的**：

比如float可以**"基本保证6位有效数字精确"**，那么是不是我只要在6个有效数字内使用float就能保证数据准确呢？

答案当然不是，**浮点数的不精确是绝对的，即便是在有效数字内。**

这主要是因为某些十进制小数，转换成浮点数用二进制存储，会出现无限循环的情况，此时有限位数的浮点数必然是无法精确表示无限循环小数的！

比如十进制小数`0.1`转换成二进制表示：

十进制正小数（0.开头）转换成二进制，先用小数部分乘以2，取结果的整数部分(必然是1或者0)：

1. 然后小数部分继续乘2
2. 直到小数部分为0，或者已经达到了最大的位数
3. 最终的结果（0.开头）正序排列

0.1 * 2 = 0.2 ---> 取整数部分0

0.2 * 2 = 0.4 ---> 取整数部分0

0.4 * 2 = 0.8 ---> 取整数部分0

0.8 * 2 = 1.6 ---> 取整数部分1

0.6 * 2 = 1.2 ---> 取整数部分1

0.2 * 2 = 0.4 ---> 取整数部分0

0.4 * 2 = 0.8 ---> 取整数部分0

0.8 * 2 = 1.6 ---> 取整数部分1

....

所以十进制小数0.1转换成二进制小数是：0.000110011001100....(1100四位无限循环)

于是我们可以得出结论：

**很多十进制小数转换成二进制时，会存在循环小数的情况。那么有限有效数字的浮点数就不能准确表示这个数字了，那些超出表示位数的数据就被截断丢失了，数据失真，精度丢失。这种小数并不少见，所以浮点数的不精确是绝对的。**

### 2.3 字符类型

![image-20241015100509494](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015100509494.png)

注：

1. 转义字符中的回车，含义来源于早期的打字机设备，它表示将打印头(光标)移动到行首，它和换行没什么关系。
2. 转义字符中的换行表示结束某一行，转而从下一行的开头开始。

**字符处理函数：**

**包含头文件<ctype.h> 。**

```c
// 检查字符类型函数
int isalnum(int c);         /* Is c alphanumeric? 检查字符c是否是一个字母或数字 */

int isalpha(int c);         /* Is c alphabetic? 检查字符c是否是一个字母 */

int isblank(int c);         /* 检查字符c是否是一个空白字符(只包括空格、制表)*/
int isspace(int c);         /* 检查字符c是否是一个空白字符(包括空格、制表、换行、换页等)*/

int isdigit(int c);         /* Is c a decimal digit? 检查字符c是否是一个十进制整数 */

int islower(int c);         /* Is c a lower-case letter? 检查字符c是否是一个小写字母 */
int isupper(int c);         /* Is c an upper-case letter? 检查字符c是否是一个大写字母 */

int ispunct(int c);         /* Is c punctuation? 检查字符c是否是一个标点符号 */

int isxdigit(int c);        /* Is c a hexadecimal digit? 检查字符c是否是一个十六进制数 */

// 字符大小写转换函数
int tolower(int c);     // 如果字符 c 是大写字母，则转换为对应的小写字母；否则，返回原字符。
int toupper(int c);     // 如果字符 c 是小写字母，则转换为对应的大写字母；否则，返回原字符。
```

**读写字符：**

**对char类型字符数据进行读/写，更推荐使用以下两个标准库函数。即getchar和putchar函数**

`putchar`函数用于将单个字符打印到显示器上，其函数的声明如下：

```c
int putchar(int c);
```

其作用是向**标准输出缓冲区(stdout)**写入一个字符，并且直接返回该字符作为返回值，如果写入过程发生意外错误，该函数会返回**EOF(End of File)**。

这就意味着此字符会暂存缓冲区，直到缓冲区满、遇到换行符或者程序结束等场景时，缓冲区刷新，内容才会显示在屏幕上。

`getchar`函数用于从键盘录入中读取读单个字符，其函数声明如下:

```c
int getchar(void);
```

此函数调用不需要任何参数，它会从**标准输入缓冲区(stdin)**中读取一个字符，并且把读取到的字符作为返回值返回。如果已经读取到流(数据源)的末尾或者发生意外错误，此函数会返回EOF。

注意：

1. getchar函数在读字符时，仍然不会自动跳过空白字符。
2. putchar 和 getchar 函数是针对char类型字符处理专门优化的函数，它们的效率要高于 printf 和 scanf，处理char数据请优先使用它们。

**循环读stdin缓冲区的一行字符-惯用法**

![image-20241015102443313](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015102443313.png)

### 2.4 数据类型转换

**将浮点常量赋值给 float 类型变量时，一个好的习惯是在常量后面加字符 f。如：`f = 3.14f`。如果没有后缀 f，那么字面值常量 3.14 是 double 类型，会引发隐式转换。**

**转换等级：**

![image-20241015103534854](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015103534854.png)

- 整数提升
  - **当表达式中仅有int以及int以下等级的类型参与时，表达式的结果一律是int(或者unsigned int)。**比如：
    1. char + char = int
    2. short + short = int
    3. char + short = int
  - 这是因为在C语言的设计中，转换等级小于int的类型参与表达式运算时，先将它们提升到int(或unsigned int)，这种语法设计就叫做"整数提升"。
  - 这么设计的目的也很简单：因为short和char在参与算术运算时，它们的取值范围都太小了，如果`char + char = char`成立，那么会经常发生溢出，而溢出往往导致数据失真。
- 如果操作数中有一个是 `long double` 类型，其余操作数都会被隐式转换为 `long double`。
- 否则，如果有一个是 `double` 类型，其余操作数都会被隐式转换为 `double`。
- 否则，如果有一个是 `float` 类型，其余操作数都会被隐式转换为 `float`。
- 否则，如果有一个是 `long long` 类型，其余操作数都会被隐式转换为 `long long`。
- 否则，如果有一个是 `long` 类型，其余操作数都会被隐式转换为 `long`。
- 如果以上类型在表达式中都没有出现，则遵循"整数提升"原则。也就是说结果是int或unsigned int。

注意：

在上述表达式相关的隐式类型转换时，我避开了无符号的整数类型。

实际上C语言有以下明确的语法规定：

**同一转换等级的有符号整数和无符号整数一起参与运算时，有符号整数会转换成对应的无符号整数。**



**强制类型转换：**

**在C语言中，"(type_name)"被视为一元运算符，而一元运算符的优先级是高于二元运算符的。（这意味着强转在一个表达式中往往会优先运算，这是一个非常重要的设计）**

```c
(type_name) expression      // type代表想要强转成的类型
```

**强转在以下场景中比较常用：**

- 提升表达式结果的精度。一个非常典型的例子就是：一个表达式因所有操作数都是整数，结果会得到一个截断数据的整数，如两个整数相除。在这种情况下就可以使用强转来提升表达式结果的精度，如下列代码：

  - ![image-20241015104937446](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015104937446.png)

- 计算浮点数的小数部分。

  - ```c
    float f = 3.14159, fractional_part;
    fractional_part = f - (int)f;
    ```

- 强转类型转换还经常用于避免数据溢出。

  - ```c
    // 此表达式右值的结果在int范围内不会溢出，所以这里隐式转换就可以了
    long long millisPerDay = 24 * 60 * 60 * 1000;   
    
    // 此表达式右值的结果超出int范围溢出，这里如果只隐式转换就会数据失真，所以需要强转
    long long nanosPerDay = (long long)24 * 60 * 60 * 1000 * 1000 * 1000;   
    ```

### 2.5 给类型定义别名

我们可以使用`typedef`关键字用于为现有的数据类型创建新的名称，即**类型别名**。

```c
typedef 现有类型的名字 别名;
```

在C语言标准库中，常用"_t"作为后缀结尾表明此类型名是一个别名。常见的如：`size_t`、`int32_t`等。我们也可以模仿采用这种风格。

**类型别名如何提升跨平台性移植性**

C语言标准库中，有非常多这样为了兼顾平台移植性而被定义的类型别名，比如：

1. **size_t类型。**此类型在任何平台下，都代表一个无符号的整数类型。在大多数情况下，它被设计为和平台位数一致的存储大小，比如32位平台下，它就是一个32位的无符号整数。size_t非常有用常用，它广泛用于表示那些在逻辑上不会为负数的概念，如：

   1. 数组的长度
   2. 字符串的长度
   3. 某个数据结构中的元素、结点的数量
   4. 内存大小，比如sizeof运算符的结果类型就是size_t
   5. ...

   **size_t非常常见常用，是C标准中的一种类型别名，使用它仅需要包含头文件stdio.h就可以了，要记住这个类型别名。**

2. **ssize_t类型。**在Linux环境，`ssize_t` 是一个与平台相关的有符号整数类型。它的大小取决于平台的位数：

   1. 在32位平台上，`ssize_t` 通常是一个32位的有符号整数。
   2. 在64位平台上，`ssize_t` 通常是一个64位的有符号整数。

   可以把ssize_t视为size_t的有符号版本。但需要注意的是：**ssize_t类型仅在Linux环境下使用，size_t则是C语言标准的一部分，是通用的。**

3. **`int8_t`, `int16_t`, `int32_t`, `int64_t`**: 无论任何平台下，分别表示确切的8、16、32、64位有符号整数。

4. **`uint8_t`, `uint16_t`, `uint32_t`, `uint64_t`**: 无论任何平台下，分别表示确切的8、16、32、64位无符号整数。

## 3.运算符和表达式

### 3.1 运算符优先级和结合性举例

**解引用运算符和自增自减运算符结合：**

p是一个指向int数组首元素的int指针类型，对于表达式`*p++`，该表达式是如何进行计算的呢？分析如下：

1. 后缀自增自减符号在表达式中拥有最高的计算优先级，所以整个表达式中`p++`最先进行计算。
2. 后缀形式的`p++`表达式：
   1. 它的主要作用是直接返回当前p的值
   2. 副作用是将p的值加1，即指向数组的下一个元素。
3. 接下来，整个表达式`*p++`：
   1. 它的主要作用就是返回指针p解引用后的结果，也就是p指针指向的元素的取值。
   2. 副作用则仍然是**p会自增1（p指向数组下一个元素）**。

***p++表达式常用于利用指针遍历数组，尤其是在字符串遍历操作当中十分常见。**

对于表达式`++*p`，该表达式是如何进行计算的呢？分析如下：

1. 在表达式 `++*p` 中，前缀自增运算符 `++` 和解引用运算符 `*` 都作用于指针`p`。
2. 前缀自增自减和解引用运算符的优先级是一样的，那么考虑它们的结合性，而它们是右结合的，即从右往左计算。
3. 先计算`*p`这个表达式：
   1. 主要作用是返回指针p解引用后的结果，即返回指针p指向的元素取值。
   2. 没有副作用
4. 整个表达式`++*p`：
   1. 主要作用是返回`*p`自增1以后的结果，此时返回的就不再是指针了，而就是一个普通的int取值。
   2. 副作用是`*p`的结果自增1，即将p指针指向的元素取值自增了1。

**++\*p表达式比较少见，不常用，了解该表达式的运算分析即可。**

**结合性对于表达式运算顺序影响的举例：**

**首先看一个简单的例子：**

`a + b - c`或者`a * b / c`如何计算呢？

任何人都会觉得很简单——从左往右运算呗，那么为什么呢？

这就是结合性的作用：两个表达式中的运算符分别都具有相同的优先级，那么考虑运算顺序就需要考虑它们的结合性。而它们的结合性是左结合的，于是整个表达式的运算顺序就是从左往右计算。

**再举一个例子：**

假如`s`是一个Student结构体对象，`math`成员表示Student对象的数学成绩。那么表达式`s.math++`是如何运算的呢？

再假如`p`是一个指向s对象的指针，那么表达式`p->math++`是如何运算的呢？

也许你还不懂结构体的语法，但没有关系。`->`、`++`、`.`这三个运算符显然具有同样的优先级，于是它们之间的运算就需要考虑结合性。

而这些运算符的结合性都是`左结合性`，于是整体的运算就是从左往右的——先获取s对象的math数学成绩，然后将这个成绩自增1。

**最后我们再看一个例子：**

对于数组的一个区间`[a, b]`，表达式`(b - a >> 1) + a`的含义是什么？

表达式 `(b - a >> 1) + a` 是用来计算区间 `[a, b]` 的中间值的。

1. `b - a` 计算出区间的长度。（算术运算符在所有二元运算符中优先级最高，先计算）
2. `>> 1` 是右移一位操作，相当于除以 2，用于将区间长度除以 2，得到中间值的偏移量。
3. 最后再加上 `a`，得到的就是区间 `[a, b]` 的中间值。

相信结合这些例子，你对运算符的优先级和结合性都有一定的理解了。

### 3.2 短路

C语言的逻辑运算符非常简单，只有三个：

1. 短路与(&&)：当且仅当两个操作数都为真（非零）时，结果为真。
2. 短路或(||)：如果至少一个操作数为真（非零），结果为真。
3. 逻辑非(!)：一元运算符，只对单个操作数取反。如果操作数为真（非零），结果为假（0）；如果操作数为假（0），结果为真（非零）。

**注意：C 语言会把任何零值当作 false，任何非零值当作 true。所以理论上来说，逻辑运算符可以连接任意数据类型，因为在C语言中任意数据类型都有零值和非零值。**

所谓的短路指的是：

1. 短路与(&&)，如果左操作数的值已经是假(零值)了，那么右操作数则不进行计算，直接返回false。
2. 短路或(||)，如果左操作数的值已经是真(非零值)了，那么右操作数则不进行计算，直接返回true。

短路的好处不仅仅是减少运算次数，提高效率，**更重要的是避免程序中的一些错误**，比如：

```c
(i != 0) && (j / i > 0)
```

如果没有短路计算，上面的表达式可能就会出现除零错误，导致程序崩溃。

**一个非常经典的问题是：**

表达式`i < j < k`在 C 语言中是合法的，但可能不是你所期望的含义。

比较运算符是左结合性的，所以`i < j < k`等价于`(i < j) < k`，换句话说，该表达式首先检测 i 是否小于 j，然后用比较后产生的结果 (0 或者 1) 和 k 进行比较。

若要测试 j 是否位于 i 和 k 之间，我们应该使用：`i < j && j < k`。

### 3.3 位运算符

下面用两个表达式来描述移位运算符的基本作用，其中`i`是整数，`j`是一个**正整数**：

1. `i << j`：将 `i` 的位模式向左移动 `j` 位。

   1. 移出去的高位丢弃，并在低位补0。
   2. 实际上该操作相当于将`i`乘以 2j（如果没有溢出的话）
   3. 此表达式的主要作用是返回`i`移位运算后的结果
   4. **此表达式一般没有副作用，不会改变`i`变量的取值，移位运算符没有赋值的作用！！**

2. `i >> j`：将 `i` 的位模式向右移 `j` 位。

   1. 移出去的低位丢弃，如果`i`是无符号数或者非负值，则在左边补 0。
   2. 如果 i 是负值，其结果会根据编译器平台实现不同而不同：一些实现会在左边补 0，一些实现会在左边补 1。
   3. **在`i`是非负数的情况下**，实际上该操作相当于将`i`除以2^j（注意整数除法的结果还是整数）
   4. 此表达式的主要作用是返回`i`移位运算后的结果
   5. **此表达式一般没有副作用，不会改变`i`变量的取值，移位运算符没有赋值的作用！！**

   ![image-20241015161710374](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015161710374.png)

   总结：

   1. 从上面的例子可以看出，对无符号整数左移 j 位，相当于乘以 2^j (不发生溢出的情况下)；
   2. 对无符号整数右移 j 位，相当于除以 2^j。

**右移位运算符的使用细节**

编程语言中的右移位运算符(不仅仅C语言)，通常有两种行为表现：

1. **算术右移**：算术右移会在高位插入符号位的副本（对于负数是1，正数是0），**算术右移位运算通常用于有符号数，因为它可以保持整数的符号不变。**
   1. 对一个负数进行算术右移会在高位补1。
   2. 对一个正数进行算术右移会在高位补0。
2. **逻辑右移**：逻辑右移不考虑整数的符号，总是在高位补0。**逻辑右移显然不适用于移位有符号数，它用于移位无符号数。**

**C语言标准中规定，在右移位无符号数时，采用逻辑右移。但当右移位有符号数时，采取上述哪种行为取决于编译器平台的实现。**

**当然，在大多数现代编译器和平台上（比如MSVC/GCC/Clang等），右移位运算符都是算术右移的，也就是在现代编译平台上，右移位运算符不会改变有符号数的符号。**

综上所述，关于右移位运算符的使用我们提出以下建议：

1. 为了更好的平台移植性和安全性，可以直接对无符号数做右移位运算，这样就不会出现符号问题了。
2. 如果要对有符号数做移位运算，请自行确认编译器行为，避免跨平台时出现移位符号问题。

扩展：

由于C语言在右移位运算上的灵活性，可能会导致一些"编码陷阱"，所以C以后的高级编程语言一般都会对右移位运算符做更多的限制和规定。比如：

1. Java会直接提供两个右移位运算符：算术右移（`>>`）和逻辑右移（`>>>`）
2. Python直接禁用了逻辑右移，总是执行算术右移。



**按位运算符中，比较需要留意的是按位异或。它具有以下一些非常优秀的性质：**

1. a ^ 0 = a;	任何整数异或0得到的都是它本身
2. a ^ a = 0;	任意整数异或自己得到的都是0
3. a ^ b = b ^ a;	异或运算满足交换律
4. (a ^ b) ^ c = a ^ (b ^ c); 	异或运算满足结合律

#### 3.3.1 判断是否为2的正整数幂

**给定一个正整数，请定义一个函数判断它是否为2的正整数幂。**

例如：1, 2, 4, 8, 16, ....就是2的正整数幂。

下面我们先观察一下2的幂整数的位模式：

1：0001

2：0010

4：0100

8：1000

....

很显然**一个正整数，如果它是2的幂，那么它的二进制位表示中仅有一位是1，其余位都是0。**

利用这个性质，我们将该整数和该整数减1做按位与运算，结果是0就说明该整数是2的幂。如下：

4 (0100) & 3 (0011) = 0

8 (1000) & 7 (0111) = 0

```c
bool is_power_2(int n) {
    return (n & (n - 1)) == 0;
}
```

#### 3.3.2 求LSB

**给定一个不为0的整数，编写函数找出它值为1的最低有效位 (称之为Last Set Bit)。**

比如：LSB的结果是1表示此整数的最低位就是1, 2则表示倒数第二位是第一个1, 4表示倒数第三位是第一个1.... 

一个示例如下：

输入：n = 24

输出：8

解释：24的二进制表示为 11000，值为 1 的最低有效位是倒数第四位，则输出 2^3，那么lsb就是8。

![image-20241015164446920](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015164446920.png)	

优化：

利用给出一个整数的补码，请求它相反数的补码的知识。

例如：

x的补码形式：0101 1100

-x的补码形式，则可以利用补码的一个性质来直接求解：

**x + (-x) = 1, 000...0 (其中0一共有n个，高位的1溢出被舍掉)，所以结果 = 0**

于是我们可以找到x的二进制补码中，值为1的最低有效位(也就是last set bit)，那么它的相反数的补码就是：

1. last set bit位保持不变。
2. 从last set bit的高一位开始，所有高位取反。

于是-x的补码就是：1010 0100

通过这个案例，我们就发现：x和-x的位模式，last set bit是一致的，高于last set bit的位全部相反，低于last set bit的位全部是0。

所以只需要将x和-x进行按位与操作，就可以找到last set bit了。

参考代码如下：

```c
int find_last_set_bit(int n) {
    return n & (-n);
}
```

#### 3.3.3 找出数组中出现一次的元素

**给定一个非空的整数数组nums，已知某个元素只出现了一次，其余元素均出现两次，那么请你找出这个只出现一次的元素。**

使用异或运算即可，因为异或运算有以下性质：

1. 自己和自己异或为0，0和别人异或都是别人。
2. 异或运算还满足交换律和结合律。

于是只需要将数组中的所有元素，全部用`^`运算符链接起来，这样最终的结果就是那个唯一的元素。

**给定一个整数数组，其中有两个元素只出现一次，其余元素都出现了两次。要求找出这两个唯一的元素。**

![](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015171514875.png)

![image-20241015171529491](https://tonve2.oss-cn-shanghai.aliyuncs.com/image-20241015171529491.png)

为什么在找到 **LSB（最低设置位）** 后，使用它进行分组能够确保数组中的其他成对出现的元素也能正确地被分组和抵消？

由于 `x` 和 `y` 在 `lsb` 位上不同，一个在这一位上是 `1`，另一个是 `0`，因此：

- `x` 会被分到 **组1**（`lsb` 位为 `1`）
- `y` 会被分到 **组2**（`lsb` 位为 `0`）

考虑数组中其他所有成对出现的元素。假设一个元素 `z` 出现了两次：

- **同一元素的两次出现**：由于 `z` 是相同的数字，它们在所有位上的值都相同，包括 `lsb` 位。
- 分组结果：两个 `z` 都会被分到 **同一组**，要么都在组1，要么都在组2。

## 4.语句

### 4.1 switch语句

#### 4.1.1 C语言switch的特点

1. `switch (expression)`的小括号中的表达式的结果必须是**整型或字符型**。浮点数、字符串等其他类型都不行。
   1. 浮点型是不精确的，不适用于switch精准匹配case标签
   2. 字符串等其余类型比较复杂，匹配case标签过程会耗费较多性能，这违背C语言switch高效的设计初衷。
2. **case关键字后面必须紧跟一个常量表达式，不能是变量或者一个运行时才能确定的表达式。**
   1. 也就是说，可以跟一个字面值常量，也可以跟一个宏常量。
   2. 但不能是一个普通的变量或变量表达式。
3. C语言的switch语句具有"静态的、硬编码"的特点，即switch的每一个case分支都必须是在编译时已知的常量表达式。这种设计使得：
   1. **switch在匹配case分支时，并不会像if多分支语句一样从上到下挨个匹配，而是直接匹配并跳转到对应的case标签。**
   2. **switch语句在处理多个离散整数值的条件判断时，非常高效，在这种场景下它是if多分支的优化版。**
   3. 当然，这种硬编码静态分支的设计也使得switch的灵活性降低，使用场景比较受限制。
4. `default`分支不是必需的，但推荐使用它来处理意外情况，增强程序的健壮性。**和if多分支不同的是，default分支不一定要放到最后。实际上switch语句中每个分支的书写顺序对switch而言是无所谓的。**
5. 如果整个switch中没有分支能匹配，且没有default分支，那么switch不执行，代码会继续执行switch语句后面的部分。

#### 4.2.2 case穿越

我们知道switch结束有两种可能：

1. 碰到了break语句结束switch
2. 执行完整个switch结束

所以，当某个case分支的末尾没有`break`，那么程序就会继续执行下一个case分支，直到遇到break或者执行完整个switch。这种语法现象就是所谓的"case穿越"(case穿刺)。

一个比较好利用case穿越的程序是：

```c
char grade = 'B';

switch (grade) {
    case 'A': case 'B': case 'C':
        printf("通过了考试!\n");
        break;
    case 'D': 
        printf("不及格,需要补考!\n");
        break;
    default:
        printf("输入有误!\n");
        break;
}
```